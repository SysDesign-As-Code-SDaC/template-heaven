---
globs: *.py
description: Python coding standards and best practices for Template Heaven
---

# Python Coding Standards

## ðŸ Code Quality Requirements

### Documentation Standards
- **Comprehensive docstrings** required for all classes, methods, and functions
- Use **Google-style docstrings** with proper type hints
- Include **parameter descriptions**, **return types**, and **example usage**
- Document **dependencies**, **integrations**, and **configuration requirements**

### Type Hints
- **Mandatory type hints** for all function parameters and return values
- Use `typing` module for complex types (Dict, List, Optional, Tuple)
- Import types from `typing` at the top of files
- Use `Optional[Type]` for nullable parameters

### Code Structure
- **Class-based architecture** for complex functionality
- **Single responsibility principle** - each class/method has one clear purpose
- **Error handling** with specific exception types and meaningful messages
- **Logging** using Python's `logging` module with appropriate levels

## ðŸ“‹ Example Code Template

```python
#!/usr/bin/env python3
"""
Module description with clear purpose and functionality.

This module provides [specific functionality] for the Template Heaven project.
It integrates with [external systems] and handles [specific operations].

Dependencies:
    - requests: HTTP client for API calls
    - psycopg2: PostgreSQL database adapter
    - redis: Redis client for caching

Author: [Author Name]
Created: [Date]
"""

import logging
from typing import Dict, List, Optional, Tuple
from datetime import datetime
from pathlib import Path

from .utils.database import Database
from .utils.cache import Cache


class ExampleClass:
    """
    Example class demonstrating proper documentation and structure.
    
    This class handles [specific functionality] with proper error handling,
    logging, and integration with external systems.
    
    Attributes:
        config (Dict): Configuration dictionary
        logger (logging.Logger): Logger instance
        db (Database): Database connection instance
    """
    
    def __init__(self, config: Dict, verbose: bool = False):
        """
        Initialize the ExampleClass instance.
        
        Args:
            config: Configuration dictionary containing required settings
            verbose: Enable verbose logging output
            
        Raises:
            ValueError: If required configuration keys are missing
            ConnectionError: If database connection fails
        """
        self.config = config
        self.logger = logging.getLogger(__name__)
        self.verbose = verbose
        
        # Validate configuration
        self._validate_config()
        
        # Initialize components
        self.db = Database(config)
        self.cache = Cache(config)
    
    def process_data(self, data: List[Dict], batch_size: int = 100) -> Tuple[int, List[str]]:
        """
        Process data with proper error handling and validation.
        
        Args:
            data: List of dictionaries containing data to process
            batch_size: Number of items to process in each batch
            
        Returns:
            Tuple containing:
                - int: Number of successfully processed items
                - List[str]: List of error messages for failed items
                
        Raises:
            ValueError: If data format is invalid
            DatabaseError: If database operations fail
        """
        if not data:
            raise ValueError("Data list cannot be empty")
            
        processed_count = 0
        errors = []
        
        try:
            for i in range(0, len(data), batch_size):
                batch = data[i:i + batch_size]
                result = self._process_batch(batch)
                processed_count += result['success_count']
                errors.extend(result['errors'])
                
        except Exception as e:
            self.logger.error(f"Failed to process data: {e}")
            raise
            
        return processed_count, errors
    
    def _validate_config(self) -> None:
        """Validate configuration dictionary."""
        required_keys = ['database_url', 'redis_url', 'api_key']
        missing_keys = [key for key in required_keys if key not in self.config]
        
        if missing_keys:
            raise ValueError(f"Missing required configuration keys: {missing_keys}")
    
    def _process_batch(self, batch: List[Dict]) -> Dict:
        """
        Process a batch of data items.
        
        Args:
            batch: List of data items to process
            
        Returns:
            Dictionary with 'success_count' and 'errors' keys
        """
        # Implementation details here
        pass
```

## ðŸ”§ Specific Requirements

### Error Handling
- Use **specific exception types** (ValueError, ConnectionError, etc.)
- Include **meaningful error messages** with context
- **Log errors** before raising exceptions
- Use **try-except blocks** for external API calls and database operations

### Logging
- Use **structured logging** with appropriate levels (DEBUG, INFO, WARNING, ERROR)
- Include **context information** in log messages
- **Log function entry/exit** for complex operations
- Use **logger names** that match module hierarchy

### Configuration Management
- **Validate configuration** on initialization
- Use **type hints** for configuration parameters
- Provide **default values** where appropriate
- **Document configuration requirements** in docstrings

### Database Operations
- Use **connection pooling** for database connections
- **Handle connection failures** gracefully
- Use **parameterized queries** to prevent SQL injection
- **Log database operations** for debugging

### API Integration
- Use **async/await** for I/O operations when possible
- **Handle rate limiting** and retry logic
- **Validate API responses** before processing
- **Log API calls** for monitoring and debugging

## ðŸ§ª Testing Requirements

### Test Structure
- **Unit tests** for all public methods
- **Integration tests** for external system interactions
- **Mock external dependencies** (APIs, databases, file systems)
- **Test error conditions** and edge cases

### Test Documentation
- **Test docstrings** explaining what is being tested
- **Arrange-Act-Assert** pattern for test structure
- **Descriptive test names** that explain the scenario
- **Test data setup** and cleanup

## ðŸ“¦ Dependencies

### Required Packages
- **requests**: HTTP client for API calls
- **psycopg2-binary**: PostgreSQL database adapter
- **redis**: Redis client for caching
- **pyyaml**: YAML configuration file parsing
- **aiohttp**: Async HTTP client (when needed)

### Development Dependencies
- **pytest**: Testing framework
- **pytest-asyncio**: Async testing support
- **pytest-mock**: Mocking utilities
- **black**: Code formatting
- **flake8**: Linting
- **mypy**: Type checking

## ðŸš¨ Validation Requirements

### Manual Validation
- **Test all functionality** manually before committing
- **Verify error handling** with invalid inputs
- **Check logging output** for proper information
- **Validate configuration** with different settings
- **Test integration** with external systems

### Code Review Checklist
- [ ] Comprehensive docstrings with type hints
- [ ] Proper error handling and logging
- [ ] Configuration validation
- [ ] Unit tests with good coverage
- [ ] Manual testing completed
- [ ] Dependencies documented
- [ ] Integration points validated