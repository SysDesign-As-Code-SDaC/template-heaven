---
globs: templateheaven/api/**,templateheaven/database/**,scripts/**,*.py,*.yml,*.yaml
description: Security and privacy standards for Template Heaven private repository system
---

# Security and Privacy Standards

## üîê Private Repository Security

### Repository Protection
- **Private repository status** must be maintained at all times
- **Never fork public upstream templates** directly into the repository
- **Use sync scripts** to pull templates without exposing organization work
- **Regular security audits** of repository access and permissions

### Access Control
- **Minimal necessary permissions** for all users and systems
- **Regular access review** and cleanup of inactive accounts
- **Two-factor authentication** required for all accounts
- **IP allowlisting** for sensitive operations where possible

## üîë Authentication Security

### Password Security
- **Strong password policies** with complexity requirements
- **Secure password hashing** using bcrypt or Argon2
- **Password expiration** and rotation requirements
- **Account lockout** after failed login attempts

### Token Management
- **JWT tokens** with appropriate expiration times
- **Secure token storage** and transmission
- **Token refresh mechanisms** with proper validation
- **Immediate token revocation** for compromised accounts

### Authentication Code Pattern
```python
# templateheaven/api/services/auth_service.py
from passlib.context import CryptContext
from jose import JWTError, jwt
from datetime import datetime, timedelta
import secrets

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

class AuthService:
    """Authentication service with security best practices."""

    @staticmethod
    def hash_password(password: str) -> str:
        """
        Hash password using bcrypt.

        Args:
            password: Plain text password

        Returns:
            Hashed password string
        """
        return pwd_context.hash(password)

    @staticmethod
    def verify_password(password: str, hashed: str) -> bool:
        """
        Verify password against hash.

        Args:
            password: Plain text password
            hashed: Hashed password

        Returns:
            True if password matches hash
        """
        return pwd_context.verify(password, hashed)

    @staticmethod
    def create_access_token(data: dict, expires_delta: timedelta = None):
        """
        Create JWT access token.

        Args:
            data: Payload data to encode
            expires_delta: Token expiration time

        Returns:
            Encoded JWT token
        """
        to_encode = data.copy()

        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(minutes=15)

        to_encode.update({"exp": expire, "type": "access"})
        encoded_jwt = jwt.encode(
            to_encode,
            settings.JWT_SECRET_KEY,
            algorithm=settings.JWT_ALGORITHM
        )
        return encoded_jwt

    @staticmethod
    def generate_secure_token(length: int = 32) -> str:
        """
        Generate cryptographically secure random token.

        Args:
            length: Token length in bytes

        Returns:
            Secure random token as hex string
        """
        return secrets.token_hex(length)
```

## üåê API Security

### Request Security
- **Input validation** and sanitization on all endpoints
- **Rate limiting** to prevent abuse and DoS attacks
- **CORS configuration** appropriate for deployment environment
- **Request size limits** to prevent memory exhaustion

### API Security Headers
```python
# templateheaven/api/middleware.py
from fastapi import Request, Response
from fastapi.middleware.cors import CORSMiddleware
import time

class SecurityHeadersMiddleware:
    """Add security headers to all responses."""

    def __init__(self, app):
        self.app = app

    async def __call__(self, request: Request, call_next):
        start_time = time.time()
        response = await call_next(request)
        process_time = time.time() - start_time

        # Security headers
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains"
        response.headers["Referrer-Policy"] = "strict-origin-when-cross-origin"
        response.headers["Content-Security-Policy"] = "default-src 'self'"

        # Performance headers
        response.headers["X-Process-Time"] = str(process_time)

        return response

class RateLimitMiddleware:
    """Rate limiting middleware."""

    def __init__(self, app, requests_per_minute: int = 60):
        self.app = app
        self.requests_per_minute = requests_per_minute
        self.requests = {}

    async def __call__(self, request: Request, call_next):
        client_ip = request.client.host if request.client else "unknown"

        # Simple in-memory rate limiting (use Redis for production)
        current_time = time.time()
        if client_ip in self.requests:
            requests = [t for t in self.requests[client_ip] if current_time - t < 60]
            if len(requests) >= self.requests_per_minute:
                return Response(
                    content='{"error": "Rate limit exceeded"}',
                    status_code=429,
                    media_type="application/json"
                )
            self.requests[client_ip] = requests
        else:
            self.requests[client_ip] = []

        self.requests[client_ip].append(current_time)
        response = await call_next(request)
        return response
```

## üóÑÔ∏è Database Security

### Data Protection
- **Encryption at rest** for sensitive data
- **Connection encryption** (SSL/TLS) for all database connections
- **Parameterized queries** to prevent SQL injection
- **Access logging** for audit trails

### Database Security Configuration
```python
# templateheaven/database/connection.py
def create_secure_engine(database_url: str = None):
    """
    Create database engine with security best practices.

    Args:
        database_url: Database connection URL

    Returns:
        Securely configured SQLAlchemy engine
    """
    if database_url is None:
        database_url = DATABASE_URL

    # Ensure SSL is enabled for production
    if not database_url.startswith('sqlite'):
        if 'sslmode' not in database_url:
            if database_url.startswith('postgresql'):
                database_url += '?sslmode=require'

    engine = create_engine(
        database_url,
        poolclass=QueuePool,
        pool_size=20,
        max_overflow=30,
        pool_pre_ping=True,
        pool_recycle=3600,
        echo=False,
        future=True,
        # Security settings
        connect_args={
            "application_name": "TemplateHeaven",
            "connect_timeout": 10,
        }
    )

    return engine
```

## üîí Template Security

### Template Validation
- **Security scanning** of all template dependencies
- **Malware detection** in template files
- **License compliance** verification
- **Input validation** in template code

### Dependency Security
```python
# scripts/security_scan.py
import subprocess
import json
import os
from pathlib import Path
from typing import Dict, List

class SecurityScanner:
    """Security scanner for templates and dependencies."""

    def __init__(self):
        self.vulnerable_packages = set()
        self.load_vulnerability_db()

    def load_vulnerability_db(self):
        """Load known vulnerability database."""
        # In production, this would connect to a vulnerability database
        # For now, we'll use a simple local database
        vuln_file = Path(__file__).parent / "vulnerabilities.json"
        if vuln_file.exists():
            with open(vuln_file) as f:
                data = json.load(f)
                self.vulnerable_packages = set(data.get("vulnerable_packages", []))

    def scan_template(self, template_path: str) -> Dict[str, any]:
        """
        Scan template for security issues.

        Args:
            template_path: Path to template directory

        Returns:
            Scan results with any security issues found
        """
        issues = []

        # Check for package.json vulnerabilities
        package_json = Path(template_path) / "package.json"
        if package_json.exists():
            npm_issues = self.scan_npm_dependencies(package_json)
            issues.extend(npm_issues)

        # Check for Python requirements.txt vulnerabilities
        requirements = Path(template_path) / "requirements.txt"
        if requirements.exists():
            python_issues = self.scan_python_dependencies(requirements)
            issues.extend(python_issues)

        # Check for hardcoded secrets
        secret_issues = self.scan_for_secrets(template_path)
        issues.extend(secret_issues)

        return {
            "template_path": template_path,
            "total_issues": len(issues),
            "issues": issues,
            "security_score": self.calculate_security_score(issues)
        }

    def scan_npm_dependencies(self, package_json_path: Path) -> List[Dict]:
        """Scan npm dependencies for vulnerabilities."""
        issues = []

        try:
            with open(package_json_path) as f:
                package_data = json.load(f)

            dependencies = {**package_data.get("dependencies", {}),
                          **package_data.get("devDependencies", {})}

            for package, version in dependencies.items():
                if package in self.vulnerable_packages:
                    issues.append({
                        "type": "vulnerable_dependency",
                        "severity": "high",
                        "package": package,
                        "version": version,
                        "description": f"Vulnerable package detected: {package}"
                    })

        except Exception as e:
            issues.append({
                "type": "scan_error",
                "severity": "medium",
                "description": f"Failed to scan npm dependencies: {str(e)}"
            })

        return issues

    def scan_for_secrets(self, template_path: str) -> List[Dict]:
        """Scan template for hardcoded secrets."""
        issues = []
        secret_patterns = [
            r'password[=:]\s*["\'][^"\']+["\']',
            r'api_key[=:]\s*["\'][^"\']+["\']',
            r'secret[=:]\s*["\'][^"\']+["\']',
            r'token[=:]\s*["\'][^"\']+["\']',
        ]

        for root, dirs, files in os.walk(template_path):
            for file in files:
                file_path = Path(root) / file

                # Skip binary files and common non-text files
                if file_path.suffix in ['.jpg', '.png', '.pdf', '.zip', '.tar']:
                    continue

                try:
                    content = file_path.read_text(encoding='utf-8', errors='ignore')
                    for pattern in secret_patterns:
                        matches = re.finditer(pattern, content, re.IGNORECASE)
                        for match in matches:
                            issues.append({
                                "type": "hardcoded_secret",
                                "severity": "critical",
                                "file": str(file_path.relative_to(template_path)),
                                "line": content[:match.start()].count('\n') + 1,
                                "description": "Potential hardcoded secret detected"
                            })
                except Exception:
                    continue

        return issues
```

## üîê Privacy Protection

### Data Privacy
- **Minimal data collection** - only collect necessary information
- **Data anonymization** where possible
- **Clear privacy policies** for data handling
- **User consent** for data collection and processing

### Template Privacy
- **Remove personal data** from template examples
- **Anonymize configuration** examples
- **Document data requirements** clearly
- **GDPR compliance** for user data handling

## üö® Security Monitoring

### Logging and Alerting
- **Security event logging** for all authentication attempts
- **Failed access attempts** monitoring
- **Anomalous behavior** detection
- **Real-time alerting** for security events

### Security Monitoring Code
```python
# templateheaven/api/services/security_service.py
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional
from sqlalchemy.orm import Session

from ..database.models import SecurityEvent, User
from ..database import get_db

logger = logging.getLogger(__name__)

class SecurityService:
    """Security monitoring and alerting service."""

    @staticmethod
    def log_security_event(
        event_type: str,
        user_id: Optional[int] = None,
        ip_address: str = None,
        details: Dict = None,
        db: Session = None
    ):
        """
        Log security-related events.

        Args:
            event_type: Type of security event
            user_id: Associated user ID if applicable
            ip_address: Client IP address
            details: Additional event details
            db: Database session
        """
        try:
            if db is None:
                db = next(get_db())

            event = SecurityEvent(
                event_type=event_type,
                user_id=user_id,
                ip_address=ip_address,
                details=details or {},
                timestamp=datetime.utcnow()
            )

            db.add(event)
            db.commit()

            # Log to application logger as well
            logger.warning(f"Security event: {event_type} - User: {user_id} - IP: {ip_address}")

        except Exception as e:
            logger.error(f"Failed to log security event: {str(e)}")

    @staticmethod
    def check_failed_logins(user_id: int, db: Session = None) -> Dict:
        """
        Check for excessive failed login attempts.

        Args:
            user_id: User ID to check
            db: Database session

        Returns:
            Dictionary with analysis results
        """
        if db is None:
            db = next(get_db())

        # Check last 15 minutes for failed logins
        fifteen_minutes_ago = datetime.utcnow() - timedelta(minutes=15)

        failed_attempts = db.query(SecurityEvent).filter(
            SecurityEvent.user_id == user_id,
            SecurityEvent.event_type == "failed_login",
            SecurityEvent.timestamp >= fifteen_minutes_ago
        ).count()

        return {
            "failed_attempts": failed_attempts,
            "threshold_exceeded": failed_attempts >= 5,
            "lockout_duration": 30 if failed_attempts >= 5 else 0
        }

    @staticmethod
    def detect_anomalous_activity(user_id: int, db: Session = None) -> List[str]:
        """
        Detect anomalous user activity patterns.

        Args:
            user_id: User ID to analyze
            db: Database session

        Returns:
            List of detected anomalies
        """
        if db is None:
            db = next(get_db())

        anomalies = []
        user_events = db.query(SecurityEvent).filter(
            SecurityEvent.user_id == user_id,
            SecurityEvent.timestamp >= datetime.utcnow() - timedelta(hours=24)
        ).all()

        # Check for unusual access patterns
        if len(user_events) > 100:
            anomalies.append("Unusual high activity level")

        # Check for access from multiple locations
        ip_addresses = {event.ip_address for event in user_events if event.ip_address}
        if len(ip_addresses) > 3:
            anomalies.append("Access from multiple locations")

        return anomalies
```

## üõ°Ô∏è Infrastructure Security

### Network Security
- **Firewall configuration** to restrict access
- **VPN requirements** for sensitive operations
- **Network segmentation** for different environments
- **DDoS protection** for public-facing services

### Container Security
- **Minimal base images** for containers
- **Security scanning** of container images
- **Runtime security** with proper user permissions
- **Secret management** with external secret stores

## üîç Vulnerability Management

### Dependency Scanning
- **Automated security scanning** of all dependencies
- **Vulnerability assessment** before template inclusion
- **Regular security updates** for all packages
- **Security patch management** process

### Code Security
- **Static Application Security Testing (SAST)** integration
- **Dynamic Application Security Testing (DAST)** for web applications
- **Dependency vulnerability scanning** with tools like OWASP Dependency-Check
- **Container image scanning** for vulnerabilities

## üìã Compliance Requirements

### Audit Trail
- **Complete audit logging** for all system activities
- **Data access logging** for compliance requirements
- **Change tracking** for configuration and code
- **Retention policies** for audit data

### Compliance Standards
- **GDPR compliance** for user data handling
- **SOC 2 Type II** security controls where applicable
- **ISO 27001** security management practices
- **NIST Cybersecurity Framework** implementation

## üö® Incident Response

### Security Incidents
- **Incident response plan** with clear procedures
- **Incident classification** and escalation paths
- **Communication protocols** for security events
- **Post-incident review** and improvement process

### Breach Detection
- **Intrusion detection** systems monitoring
- **Anomaly detection** for unusual patterns
- **Log analysis** for security event correlation
- **Automated alerting** for critical security events

## üîß Security Testing

### Security Test Coverage
- **Authentication testing** for all access controls
- **Authorization testing** for role-based access
- **Input validation testing** for injection prevention
- **Session security testing** for token handling

### Penetration Testing
- **Regular security assessments** by qualified professionals
- **Vulnerability scanning** with automated tools
- **Code review** for security issues
- **Third-party security audits** for critical systems

## üìö Security Documentation

### Security Policies
- **Information security policy** document
- **Access control policy** for user management
- **Incident response plan** with procedures
- **Data classification** and handling guidelines

### Security Training
- **Regular security awareness** training for team members
- **Secure coding practices** documentation
- **Security guidelines** for new team members
- **Best practices** documentation for common tasks

## üîê Cryptographic Security

### Encryption Standards
- **AES-256 encryption** for data at rest
- **TLS 1.3** for data in transit
- **Strong key management** practices
- **Certificate management** for encrypted communications

### Key Management
- **Secure key generation** using cryptographically strong methods
- **Key rotation policies** for long-term keys
- **Key storage** in secure key management systems
- **Access controls** for cryptographic keys

## üöÄ Deployment Security

### Secure Deployment Practices
- **Infrastructure as Code** with security best practices
- **Automated security testing** in CI/CD pipeline
- **Secure configuration management** for all environments
- **Production deployment** security reviews

### Environment Security
- **Development environment** isolation from production
- **Staging environment** for security testing
- **Production hardening** with security best practices
- **Environment-specific** security configurations

## üìä Security Metrics

### Monitoring Metrics
- **Security incident frequency** and resolution times
- **Vulnerability remediation** timeframes
- **Access control effectiveness** measurements
- **Security training completion** rates

### Risk Assessment
- **Regular risk assessments** of system components
- **Threat modeling** for new features
- **Security risk register** maintenance
- **Risk mitigation** tracking and reporting

## üîó External Security Resources

### Security Tools Integration
- **GitHub Security Alerts** for dependency vulnerabilities
- **Code scanning** with GitHub CodeQL
- **Container registry** security scanning
- **Third-party security** scanning services

### Security Community
- **OWASP membership** and guideline adherence
- **Security mailing lists** and forums participation
- **Conference attendance** for security education
- **Industry best practices** adoption and adaptation

## üö® Emergency Procedures

### Security Emergency Contacts
- **24/7 security incident** response team
- **Emergency communication** channels
- **External security consultant** contacts
- **Law enforcement** coordination procedures

### Emergency Response
- **Immediate incident isolation** procedures
- **Evidence preservation** for forensic analysis
- **Stakeholder communication** protocols
- **Service restoration** planning and execution

## üìã Security Checklist

### Daily Security Tasks
- [ ] **Review security logs** for suspicious activity
- [ ] **Check system health** and availability
- [ ] **Monitor for new vulnerabilities** in dependencies
- [ ] **Verify backup integrity** and security

### Weekly Security Tasks
- [ ] **Review user access logs** and permissions
- [ ] **Update security patches** as needed
- [ ] **Test incident response** procedures
- [ ] **Review security metrics** and trends

### Monthly Security Tasks
- [ ] **Conduct security training** for team members
- [ ] **Perform vulnerability assessments** of key systems
- [ ] **Review and update security policies** as needed
- [ ] **Test disaster recovery** procedures

### Quarterly Security Tasks
- [ ] **Conduct penetration testing** of applications
- [ ] **Review compliance requirements** and status
- [ ] **Update security documentation** and procedures
- [ ] **Perform security architecture** reviews

## üîí Final Security Notes

### Critical Security Principles
- **Defense in depth** - multiple layers of security controls
- **Least privilege** - minimal necessary access for all users and systems
- **Fail securely** - systems should fail in a secure state
- **Zero trust** - verify all access requests regardless of origin

### Continuous Improvement
- **Regular security assessments** and improvements
- **Security culture** throughout the development team
- **Learning from incidents** and near-misses
- **Staying current** with security best practices and threats